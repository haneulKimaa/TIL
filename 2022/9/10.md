## ✏️ 알고리즘 - 시간복잡도, 공간복잡도

### 1. 알고리즘 복잡도 계산이 필요한 이유

하나의 문제를 푸는 다양한 알고리즘 중 어떤 알고리즘이 좋은지를 판별하기 위해 복잡도를 계산한다. 복잡도를 낮추어서 하드웨어를 효율적으로 사용할 수 있다.

### 2. 알고리즘 복잡도 계산 항목

1. 시간 복잡도 : 알고리즘 실행 속도
2. 공간 복잡도 : 알고리즘이 사용하는 메모리의 사이즈

- 알고리즘 시간 복잡도의 주요 요소는 반복문!
- 일반적으로 알고리즘에서의 복잡도는 시간 복잡도는 말한다.

### 3. 알고리즘 성능 표기법

- Big O 표기법 : O(N)
    - 알고리즘의 최대 실행 시간을 표시
    - 가장 일반적으로 사용하는 방법
- Ω 오메가 표기법 : Ω(N)
    - 최상의 실행 시간을 표기
- Θ 세타 표기법 : Θ(N)
    - 평균 실행 시간을 표기

### 4. Big O 표기법 : O(N)

- O(1) < O(logn) < O(n) < O(n^2) < O(2^n) < O(n!)
    - O(logn)의 밑은 2

        <img width="500" alt="image" src="https://user-images.githubusercontent.com/63438947/189488107-b18343de-6003-4124-bd14-fbe4d48bf85b.png">
        
    - 상수와 최고차수만 표기한다.

- n의 입력에 따라 몇 번 실행되는지 계산
    - 상수회 실행할 경우 → O(1)
    
    ```swift
    if n > 10 {
            print(n)
    }
    ```
    
- n에 따라 n번, n+10번, 3n+2번 .. → O(n)
    
    ```swift
    var a = 1
    var b = 2
    for i in 0..<n {
            print(i)
    }
    // 이 경우 n+2회 실행됨
    ```
    
    ```swift
    var a = 1
    for _ in 0..2 {
            for i in 0..<n {
                    print(i)
            }
    }
    // 이 경우 3n+1회 실행
    ```
    
- n에 따라 n^2번, n^2 + 1번 … → O(n^2)
    
    ```swift
    var a = 1
    for _ in 0..2 {
            for i in 0..<n {
                    for i in 0..<n {
                            print(i)
                    }
            }
    }
    // 이 경우 3n^2+1회 실행
    ```
    

### 5. 예시 - 1부터 n까지의 합
```swift
var sum: Int = 0
for i in 0..<n {
        sum += n
}
// O(n)
```

```swift
var sum: Int = 0
sum = n(n+1)/2
// O(1)
```
